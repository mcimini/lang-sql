================ QUERY 1 =================== 
all EMPTY TABLE but


strong_stlc_cbv.lan:
=== QUERY 1: TABLE ===
opname		arg-number

abs		1

strong_stlc_cbv_let.lan:
=== QUERY 1: TABLE ===
opname		arg-number

abs		1
let		1


strong_stlc_cbv_letrecWithType.lan:
=== QUERY 1: TABLE ===
opname		arg-number

abs		1
letrec		2
letrec		1


strong_stlc_cbv_let_and_letrec.lan: 
=== QUERY 1: TABLE ===
opname		arg-number

abs		1
letrec		2
letrec		1
let		1



================ QUERY 2 =================== 

all EMPTY TABLE but

fpl_cbv.lan:
=== QUERY 2: TABLE ===
opname		category-info

mu		Type
all		Type


fpl_cbv_with_grammar_of_dependent_types.lan:
=== QUERY 2: TABLE ===
opname		category-info

pie		Expression
mu		Type
all		Type


================ QUERY 3 =================== 

stlc_ref_only_grammar.lan:
=== QUERY 3: TABLE ===
relation		arg

step		Heap
step		Heap

stlc_CK.lan
=== QUERY 3: TABLE ===
relation		arg

step		Continuation
step		Continuation


stlc_CEK.lan
=== QUERY 3: TABLE ===
relation		arg

step		Environment
step		Continuation
step		Environment
step		Continuation


================ QUERY 4 =================== 

fpl_cbv.lan:
=== QUERY 4: TABLE ===
val		type

fold		mu
absT		all
cons		list
emptyList		list
inr		sum
inl		sum
ff		bool
tt		bool
succ		int
pair		times
zero		int
abs		arrow

and the others are consistent. 

stlc_option.lan and stlc_lists_filterToOptions.lan:
=== QUERY 4: TABLE ===
val		type

some		option
none		option
cons		list
emptyList		list
ff		bool
tt		bool
succ		int
zero		int
abs		arrow

================ QUERY 5 =================== 
all display 1 as count. 

if we duplicate the T-ABS typing rule in stlc_cbv.lan: 
=== QUERY 5: TABLE ===
opname		count

abs		2
abs		2
app		1




================ QUERY 6 =================== 

fpl_cbv.lan:

=== QUERY 6: TABLE ===
opname

app
pred
pred
if
if
fst
snd
case
case
head
head
tail
tail
appT
unfold

and the others are consistent. 

Also: 
stlc_lists_append.lan:
=== QUERY 6: TABLE ===
opname

append
append
app
pred
pred
isZero
isZero
if
if
head
head
tail
tail

stlc_option.lan:
=== QUERY 6: TABLE ===
opname

get
get
app
pred
pred
isZero
isZero
if
if
head
head
tail
tail

stlc_lists_map.lan:
=== QUERY 6: TABLE ===
opname

map
map
app
pred
pred
isZero
isZero
if
if
head
head
tail
tail

stlc_lists_mapi.lan:
=== QUERY 6: TABLE ===
opname

mapi
mapi
app
pred
pred
isZero
isZero
if
if
head
head
tail
tail

stlc_lists_range.lan:
=== QUERY 6: TABLE ===
opname

reverseRange
reverseRange
reverse
reverse
append
append
app
pred
pred
isZero
isZero
if
if
head
head
tail
tail

stlc_natural_recursor.lan:
=== QUERY 6: TABLE ===
opname

natrec
natrec
app
pred
pred
isZero
isZero
if
if
head
head
tail
tail


stlc_lists_reverse.lan:
=== QUERY 6: TABLE ===
opname

append
append
reverse
reverse
app
pred
pred
isZero
isZero
if
if
head
head
tail
tail

stlc_lists_length.lan:
=== QUERY 6: TABLE ===
opname

length
length
app
pred
pred
isZero
isZero
if
if
head
head
tail
tail


stlc_lists_filteri.lan:
=== QUERY 6: TABLE ===
opname

filteri
filteri
app
pred
pred
isZero
isZero
if
if
head
head
tail
tail

stlc_lists_filter.lan:
=== QUERY 6: TABLE ===
opname

filter
filter
app
pred
pred
isZero
isZero
if
if
head
head
tail
tail


================ QUERY 7 =================== 
error handlers. works if you have variable V1 because it does not catch E1 and {value E1}


stlc_cbv_exc.tbl
=== QUERY 7: TABLE ===
opname

try

consistent with: 
fpl_cbv.tbl:=== QUERY 7: TABLE ===
fpl_cbv_with_grammar_of_dependent_types.tbl:=== QUERY 7: TABLE ===
stlc_cbv_exc.tbl:=== QUERY 7: TABLE ===

================ QUERY 8 =================== 


=== QUERY 8: TABLE ===

fpl_cbv.lan:
opname

fix
letrec
letrec
letrec

and 
stlc_cbv_fix.tbl


stlc_cbv_letrecWithType.lan:
=== QUERY 8: TABLE ===
opname

fix
let
let
letrec
letrec
letrec

consistent: stlc_cbv_let.lan, stlc_cbv_let_and_rec.lan, 
strong_stlc_cbv_let.lan, strong_stlc_cbv_letrecWithType.lan, strong_stlc_cbv_let_and_rec.lan







